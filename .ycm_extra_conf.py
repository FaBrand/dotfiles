from itertools import takewhile
import os
import fnmatch
import ycm_core
from catkin import workspace
import logging
# These are the compilation flags that will be used in case there's no
# compilation database set (by default, one is not set).
flags = [
'-Wall',
'-Wextra',
'-Werror',
'-Wno-long-long',
'-Wno-variadic-macros',
'-fexceptions',
'-DNDEBUG',
# You 100% do NOT need -DUSE_CLANG_COMPLETER in your flags; only the YCM
# source code needs it.
#'-DUSE_CLANG_COMPLETER',
'-std=c++14',
'-x',
'c++',
'-isystem',
'/usr/include',
'-isystem',
'/usr/local/include',
'-I',
'.',
]


# Set this to the absolute path to the folder (NOT the file!) containing the
# compile_commands.json file to use that instead of 'flags'. See here for
# more details: http://clang.llvm.org/docs/JSONCompilationDatabase.html
#
# You can get CMake to generate this file for you by adding:
#   set( CMAKE_EXPORT_COMPILE_COMMANDS 1 )
# to your CMakeLists.txt file.
#
# Most projects will NOT need to set this to anything; you can just change the
# 'flags' list of compilation flags. Notice that YCM itself uses that approach.

packacke_to_database_dict = dict()

def TryFindPackageAndWorkspaceOfFile(filename):
    def IsPackageDir(directory):
        return os.path.exists(os.path.join(directory, 'package.xml'))
    def IsCatkinWorkspace(directory):
        return os.path.exists(os.path.join(directory, '.catkin_tools'))
    def HasParentDir(directory):
        return not os.path.abspath(os.path.dirname(directory)) == os.path.abspath(directory)
    def TraverseTree(directory, config = (None,None)):
        if IsPackageDir(directory):
            config = (config[0], directory)
        if IsCatkinWorkspace(directory):
            config = (directory, config[1])
        if IsCatkinWorkspace(directory) or not HasParentDir(directory):
            return config

        return TraverseTree(os.path.dirname(directory), config)
    assert os.path.isfile(filename)
    return TraverseTree(os.path.abspath(os.path.dirname(filename)))


def UpdatePackageDatabase(packacke_to_database_dict, catkin_ws, pkg_name):
    logging.debug('Updating database: {}:{}'.format(catkin_ws, pkg_name))
    if not catkin_ws or not pkg_name or pkg_name in packacke_to_database_dict:
        return

    compilation_db_path = os.path.join(catkin_ws,'build',pkg_name)
    logging.debug('Looking for a database in {}'.format(compilation_db_path))

    if not os.path.exists(compilation_db_path):
        return
    else:
        logging.info('Loading database in directory {}'.format(compilation_db_path))
        try:
            packacke_to_database_dict[pkg_name] = ycm_core.CompilationDatabase(compilation_db_path)
        except Exception as e:
            logging.error('Error while loading compilation database:' + e)
            raise e

SOURCE_EXTENSIONS = [ '.cpp', '.cxx', '.cc', '.c', '.m', '.mm' ]

def DirectoryOfThisScript():
    return os.path.dirname( os.path.abspath( __file__ ) )


def MakeRelativePathsInFlagsAbsolute( flags, working_directory ):
    if not working_directory:
        return list( flags )
    new_flags = []
    make_next_absolute = False
    path_flags = [ '-isystem', '-I', '-iquote', '--sysroot=' ]
    for flag in flags:
        new_flag = flag

        if make_next_absolute:
            make_next_absolute = False
            if not flag.startswith( '/' ):
                new_flag = os.path.join( working_directory, flag )

        for path_flag in path_flags:
            if flag == path_flag:
                make_next_absolute = True
                break

            if flag.startswith( path_flag ):
                path = flag[ len( path_flag ): ]
                new_flag = path_flag + os.path.join( working_directory, path )
                break

        if new_flag:
              new_flags.append( new_flag )
    return new_flags


def IsHeaderFile( filename ):
    extension = os.path.splitext( filename )[ 1 ]
    return extension in [ '.h', '.hxx', '.hpp', '.hh' ]


def FilterSourceFileList(sources):
    def IsValidFile(filename):
        return not '.git' in filename
    sources = [filename for filename in sources if IsValidFile(filename)]

def CreateFileIndexFromSourceList(index, sources):
    for filename in sources:
        name = os.path.basename(filename)
        if not name in index:
            index[name] = filename

def FindFilesRecursive(treeroot, pattern):
    results = []
    for base, dirs, files in os.walk(treeroot):
        results.extend(os.path.join(base, f) for f in files if f.endswith(pattern))
    return results

def GetCompilationInfoForFile( filename , database , package_path):
    # The compilation_commands.json file generated by CMake does not have entries
    # for header files. So we do our best by asking the db for flags for a
    # corresponding source file, if any. If one exists, the flags for that file
    # should be good enough.
    if IsHeaderFile( filename ):
        files_in_path = FindFilesRecursive(package_path, tuple(SOURCE_EXTENSIONS))
        FilterSourceFileList(files_in_path)
        fileIndex = dict()
        CreateFileIndexFromSourceList(fileIndex, files_in_path)

        basename = os.path.splitext( os.path.basename( filename ) )[ 0 ]

        for extension in SOURCE_EXTENSIONS:
            replacement_file = basename + extension
            if replacement_file in fileIndex:
                compilation_info = database.GetCompilationInfoForFile(fileIndex[replacement_file])
                logging.info('Using compilation info of cpp file ' + fileIndex[replacement_file])
                return compilation_info
        logging.info('Could not find compilation info for ' + filename)
        return None

    logging.debug('Using compilation info of cpp file ' + filename)
    return database.GetCompilationInfoForFile( filename )


def FlagsForFile( filename, **kwargs ):
    catkin_ws, pkg_path = TryFindPackageAndWorkspaceOfFile(filename)
    if pkg_path:
        pkg_name = os.path.basename(pkg_path)
    else:
        pkg_name = None

    UpdatePackageDatabase(packacke_to_database_dict, catkin_ws, pkg_name)

    if catkin_ws and pkg_name and (pkg_name in packacke_to_database_dict):
        # Bear in mind that compilation_info.compiler_flags_ does NOT return a
        # python list, but a "list-like" StringVec object
        logging.debug("Found database for {}".format(filename))
        compilation_info = GetCompilationInfoForFile( filename , packacke_to_database_dict[pkg_name], pkg_path)
        if not compilation_info:
            logging.info('Found no compilation info for ' + filename)
            return None
        else:
            logging.info('Could find compilation info for ' + filename)
            final_flags = MakeRelativePathsInFlagsAbsolute(
              compilation_info.compiler_flags_,
              compilation_info.compiler_working_dir_ )
    elif catkin_ws and pkg_name:
        #Fallback Tbd
        return None
    elif catkin_ws:
        #e.g. if jumped to header in devel space, no package can be found and therefore no include paths are set
        # maybe find all devel paths and add them to the include path?
        return None
    else:
        relative_to = DirectoryOfThisScript()
        final_flags = MakeRelativePathsInFlagsAbsolute( flags, relative_to )

    return { 'flags': final_flags }
